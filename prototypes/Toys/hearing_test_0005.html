<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PhaseCube – Hearing Test Alpha 5</title>
<style>
  :root { --accent: #7fe07f; }
  html,body { height:100%; margin:0; background:#000; color:#fff; font-family:monospace; overflow:hidden; }
  canvas { position:fixed; inset:0; display:block; }
  .panel {
    position:absolute; background:rgba(10,10,10,0.9); border-radius:8px; padding:10px;
    font-size:13px; pointer-events:auto; z-index:10;
  }
  #info { top:10px; left:10px; max-width:420px; }
  #controls { right:10px; bottom:10px; display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  button, input[type=range] {
    background:#111; color:var(--accent); border:1px solid #333;
    padding:6px 10px; border-radius:6px; cursor:pointer; font:inherit;
  }
  button.small { padding:4px 8px; font-size:12px; }
  label { color:#ccc; font-size:12px; margin-right:6px; }
  #analyzer {
    position:absolute; left:0; right:0; bottom:0; height:18vh;
    background:rgba(0,0,0,0.7); display:none; align-items:center; justify-content:center;
    border-top:1px solid #222;
  }
  #analyzerCanvas { width:92%; height:84%; background:#050508; border-radius:6px; }
</style>
</head>
<body>

<canvas id="cube"></canvas>

<div id="info" class="panel">
  PhaseCube Hearing Test Alpha 5<br>
  Three ear modes: Live Mic • Synth • File<br>
  Low freq → back • High → front • Stereo pan L/R<br>
  Move mouse to rotate • S save • P pause
</div>

<div id="controls" class="panel"></div>

<div id="analyzer"><canvas id="analyzerCanvas"></canvas></div>

<script>
/* ================= Config ================= */
const Config = {
  GRID: 16, SCALE: 24, FPS: 60, POINT_SIZE: 4,
  FLIP_P: 0.015, PARITY_P: 0.005, BASE_PATH_B_P: 0.73, ALPHA: 0.18,
  BIN_COUNT: 64, FFT_SIZE: 2048
};

/* ================= Global State ================= */
let canvas, ctx, acanvas, actx;
let rotX = 0, rotY = Math.PI/4, time = 0, paused = false;
let positions, grid, inputLayer;
let audioCtx, analyserL, analyserR, sourceNode = null;
let mode = 'live'; // 'live', 'synth', 'file'
let synthOsc = null, synthGain = null;
let fileBuffer = null;

/* ================= Classes ================= */
class PhaseGrid {
  constructor(size) {
    this.size = size; this.n = size**3;
    this.plasma = new Float32Array(this.n);
    this.liquid = new Float32Array(this.n);
    this.solid  = new Float32Array(this.n);
    this.parity = new Int8Array(this.n);
    for (let i=0; i<this.n; i++) {
      this.plasma[i] = Math.random()*0.8 + 0.1;
      this.liquid[i] = Math.random()*0.5;
      this.solid[i]  = Math.random()*0.3;
      this.parity[i] = Math.random()<0.5 ? 1 : 0;
    }
  }
  idx(x,y,z){ return x + y*this.size + z*this.size*this.size; }
  neighborAvg(i){
    const s=this.size, x=i%s, y=Math.floor(i/s)%s, z=Math.floor(i/(s*s));
    const get=(a,b,c)=>this.plasma[this.idx((a+s)%s,(b+s)%s,(c+s)%s)];
    return (get(x+1,y,z)+get(x-1,y,z)+get(x,y+1,z)+get(x,y-1,z)+get(x,y,z+1)+get(x,y,z-1))/6;
  }
  perturb(bias=null){
    for (let i=0;i<this.n;i++){
      if (Math.random()<Config.FLIP_P) this.plasma[i]=1-this.plasma[i];
      if (Math.random()<Config.PARITY_P) this.parity[i]^=1;
      if (bias){
        const b = bias[i];
        this.plasma[i] = Math.max(0,Math.min(1,this.plasma[i]+b*0.008));
        const jitter = (Math.abs(b)>0.05)?0.003*(1+Math.abs(b)):0.001;
        this.liquid[i] += (this.parity[i]?jitter:-jitter)*(Math.random()*0.3+0.2);
        this.liquid[i] = Math.max(0,Math.min(1,this.liquid[i]));
      }
    }
  }
  step(bias=null){
    const p0=this.plasma.slice(), l0=this.liquid.slice(), s0=this.solid.slice();
    for (let i=0;i<this.n;i++){
      const p=p0[i], l=l0[i], s=s0[i];
      const avg=(p+l+s)/3;
      const nb=Math.abs(p - this.neighborAvg(i)) + this.parity[i]*0.08;
      let probB = Config.BASE_PATH_B_P + (bias ? bias[i]*0.08 : 0);
      probB = Math.max(0.55, Math.min(0.92, probB));
      const choice = Math.random()<probB ? nb : avg;
      this.liquid[i] = Math.max(0,Math.min(1,choice));
      this.solid[i]  = s*(1-Config.ALPHA) + choice*Config.ALPHA;
    }
  }
}

class InputLayer {
  constructor(size, bins) {
    this.size = size; this.n = size**3; this.bins = bins;
    this.bias = new Float32Array(this.n);
    this.decay = 0.94; this.strength = 0.08; this.radius = Math.floor(size/6);
  }
  set(p){ this.decay=p.decay??this.decay; this.strength=p.strength??this.strength; this.radius=Math.max(1,p.radius??this.radius); }
  ingest(left, right){
    for (let i=0;i<this.n;i++) this.bias[i]*=this.decay;
    for (let b=0;b<this.bins;b++){
      const aL = left[b]||0, aR = right[b]||0;
      const energy = (aL+aR)*0.5;
      const pan = (aR-aL)*(this.size*0.16);
      const z = Math.floor((b/(this.bins-1))*(this.size-1));
      let x = Math.floor(energy*(this.size-1) + pan);
      x = Math.max(0,Math.min(this.size-1,x));
      const y = Math.floor((this.size-1)/2);
      const r = this.radius, str = this.strength;
      for (let dx=-r;dx<=r;dx++){
        for (let dy=-r;dy<=r;dy++){
          for (let dz=-r;dz<=r;dz++){
            const d2 = (dx*dx + dy*dy + dz*dz)/(r*r);
            if (d2>1) continue;
            const kernel = Math.exp(-d2*2.4);
            const idx = (x+dx) + (y+dy)*this.size + (z+dz)*this.size*this.size;
            if (idx>=0 && idx<this.n) this.bias[idx] += energy*str*kernel;
          }
        }
      }
    }
    for (let i=0;i<this.n;i++) this.bias[i]=Math.max(-0.2,Math.min(0.2,this.bias[i]));
  }
}

/* ================= Audio Tools ================= */
async function startAudioContext(){
  if (!audioCtx) {
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    analyserL = audioCtx.createAnalyser();
    analyserR = audioCtx.createAnalyser();
    analyserL.fftSize = analyserR.fftSize = Config.FFT_SIZE;
    analyserL.smoothingTimeConstant = analyserR.smoothingTimeConstant = 0.85;
  }
}

function connectSource(node){
  if (sourceNode) sourceNode.disconnect();
  sourceNode = node;
  const splitter = audioCtx.createChannelSplitter(2);
  node.connect(splitter);
  splitter.connect(analyserL,0);
  splitter.connect(analyserR,1);
}

async function modeLive(){
  await startAudioContext();
  try {
    const stream = await navigator.mediaDevices.getUserMedia({audio:{channelCount:2}});
    connectSource(audioCtx.createMediaStreamSource(stream));
  } catch(e) {
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    connectSource(audioCtx.createMediaStreamSource(stream));
  }
}

function modeSynth(){
  startAudioContext();
  if (synthOsc) synthOsc.stop();
  const type = document.getElementById('synthType').value;
  if (type==='noise'){
    const bufferSize = audioCtx.sampleRate*2;
    const buffer = audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i]=Math.random()*2-1;
    synthOsc = audioCtx.createBufferSource();
    synthOsc.buffer = buffer;
    synthOsc.loop = true;
  } else {
    synthOsc = audioCtx.createOscillator();
    synthOsc.type = type;
    synthOsc.frequency.value = document.getElementById('synthFreq').value;
  }
  synthGain = audioCtx.createGain();
  synthGain.gain.value = 0.3;
  synthOsc.connect(synthGain);
  const panNode = audioCtx.createStereoPanner();
  panNode.pan.value = document.getElementById('synthPan').value;
  synthGain.connect(panNode);
  connectSource(panNode);
  synthOsc.start();
}

async function modeFile(file){
  await startAudioContext();
  const arrayBuffer = await file.arrayBuffer();
  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  const src = audioCtx.createBufferSource();
  src.buffer = audioBuffer;
  src.loop = document.getElementById('fileLoop').checked;
  connectSource(src);
  src.start();
}

/* ================= Rendering ================= */
function getFreqData(analyser){
  const data = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(data);
  const out = new Float32Array(Config.BIN_COUNT);
  const sr = audioCtx ? audioCtx.sampleRate : 44100;
  for (let i=0;i<Config.BIN_COUNT;i++){
    const f = 20 * Math.pow(20000/20, i/(Config.BIN_COUNT-1));
    const bin = Math.floor((f/(sr/2))*data.length);
    out[i] = data[Math.min(data.length-1,bin)] / 255;
  }
  return out;
}

function draw(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const pts = [];
  const camZ = 400, fov=Math.PI/4, f=1/Math.tan(fov/2);
  const aspect = canvas.width/canvas.height;
  const cX=Math.cos(rotX),sX=Math.sin(rotX),cY=Math.cos(rotY),sY=Math.sin(rotY);
  for (let i=0,p=0;i<positions.length/3;i++,p+=3){
    let x=positions[p],y=positions[p+1],z=positions[p+2];
    let rx = cY*x + sY*z; let rz = -sY*x + cY*z;
    let ry = cX*y - sX*rz; let rz2 = sX*y + cX*rz;
    let cz = camZ - rz2;
    if (Math.abs(cz)<0.001) cz = cz<0?-0.001:0.001;
    const ndcX = (f/aspect)*(rx/cz); const ndcY = f*(ry/cz);
    pts.push({i,z:cz,x:(ndcX*0.5+0.5)*canvas.width,y:(ndcY*0.5+0.5)*canvas.height});
  }
  pts.sort((a,b)=>b.z-a.z);
  const hbase = time*0.08;
  for (const pt of pts){
    const p=grid.plasma[pt.i], l=grid.liquid[pt.i], par=grid.parity[pt.i];
    if (l<0.02) continue;
    const h = (hbase + par + p) % 1;
    const t = h*6.28318;
    const r=Math.abs(Math.sin(t))*255;
    const g=Math.abs(Math.sin(t+2))*255;
    const b=Math.abs(Math.sin(t+4))*255;
    const a=0.3 + 0.7*l;
    const sz = Config.POINT_SIZE + 6*p;
    ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${a})`;
    ctx.beginPath(); ctx.arc(pt.x,pt.y,sz,0,Math.PI*2); ctx.fill();
  }
}

function drawAnalyzer(){
  if (!audioCtx) return;
  const left = getFreqData(analyserL);
  const right = getFreqData(analyserR);
  actx.clearRect(0,0,acanvas.width,acanvas.height);
  actx.fillStyle='#000'; actx.fillRect(0,0,acanvas.width,acanvas.height);
  const w=acanvas.width, h=acanvas.height, bins=Config.BIN_COUNT;
  const barW = w/(bins*2);
  for (let i=0;i<bins;i++){
    const hL = left[i]*(h-20), hR = right[i]*(h-20);
    actx.fillStyle = `rgb(0,${100+155*left[i]},0)`;
    actx.fillRect(i*barW*2, h-hL, barW-2, hL);
    actx.fillStyle = `rgb(${100+155*right[i]},0,${100+155*right[i]})`;
    actx.fillRect(i*barW*2 + barW, h-hR, barW-2, hR);
  }
}

/* ================= Loop ================= */
function loop(){
  requestAnimationFrame(loop);
  if (!paused){
    time += 1/Config.FPS;
    let bias = null;
    if (audioCtx && analyserL && analyserR){
      const left = getFreqData(analyserL);
      const right = getFreqData(analyserR);
      inputLayer.ingest(left,right);
      bias = inputLayer.bias;
    }
    grid.perturb(bias);
    grid.step(bias);
  }
  draw();
  if (document.getElementById('analyzer').style.display==='flex') drawAnalyzer();
}

/* ================= Init ================= */
function init(){
  canvas = document.getElementById('cube'); ctx = canvas.getContext('2d');
  acanvas = document.getElementById('analyzerCanvas'); actx = acanvas.getContext('2d');
  const resize = ()=>{
    const dpr = Math.min(window.devicePixelRatio||1,2);
    canvas.width = window.innerWidth*dpr; canvas.height = window.innerHeight*dpr;
    acanvas.width = acanvas.clientWidth*dpr; acanvas.height = acanvas.clientHeight*dpr;
  };
  window.addEventListener('resize',resize); resize();

  // lattice
  const total = Config.GRID**3;
  positions = new Float32Array(total*3);
  let ptr=0, half=(Config.GRID-1)/2;
  for (let x=0;x<Config.GRID;x++) for (let y=0;y<Config.GRID;y++) for (let z=0;z<Config.GRID;z++){
    positions[ptr++]=(x-half)*Config.SCALE;
    positions[ptr++]=(y-half)*Config.SCALE;
    positions[ptr++]=(z-half)*Config.SCALE;
  }
  grid = new PhaseGrid(Config.GRID);
  inputLayer = new InputLayer(Config.GRID, Config.BIN_COUNT);

  // UI
  const c = document.getElementById('controls');
  c.innerHTML = `
    <div class="row">
      <button class="small" id="pause">Pause</button>
      <button class="small" id="save">Save PNG</button>
    </div>
    <div class="row"><label>Mode</label>
      <button id="m-live" class="small active">Live Mic</button>
      <button id="m-synth" class="small">Synth</button>
      <button id="m-file" class="small">Load File</button>
      <input type="file" id="fileInput" accept="audio/*" style="display:none">
    </div>
    <div class="row" id="synthControls" style="display:none">
      <label>Freq</label><input type="range" id="synthFreq" min="20" max="2000" step="1" value="220">
      <label>Type</label><select id="synthType"><option>sine</option><option>square</option><option>sawtooth</option><option>triangle</option><option value="noise">noise</option></select>
      <label>Pan</label><input type="range" id="synthPan" min="-1" max="1" step="0.01" value="0">
    </div>
    <div class="row">
      <button class="small" id="showAnalyzer">Show Analyzer</button>
    </div>
    <div class="row">
      <label>p(B)</label><input type="range" id="basePB" min="0.5" max="0.95" step="0.01" value="${Config.BASE_PATH_B_P}">
      <label>Str</label><input type="range" id="str" min="0.01" max="0.2" step="0.01" value="0.08">
      <label>Decay</label><input type="range" id="dec" min="0.85" max="0.995" step="0.005" value="0.94">
    </div>`;
  
  document.getElementById('pause').onclick = ()=>{ paused=!paused; this.textContent=paused?'Resume':'Pause'; };
  document.getElementById('save').onclick = ()=>{ const a=document.createElement('a'); a.download=`alpha5_${Date.now()}.png`; a.href=canvas.toDataURL(); a.click(); };
  document.getElementById('showAnalyzer').onclick = ()=>{ 
    const vis = document.getElementById('analyzer').style.display==='flex';
    document.getElementById('analyzer').style.display = vis?'none':'flex';
    this.textContent = vis?'Show Analyzer':'Hide Analyzer';
  };

  // mode buttons
  document.getElementById('m-live').onclick = async ()=>{ mode='live'; await modeLive(); document.querySelectorAll('#controls button.active').forEach(b=>b.classList.remove('active')); this.classList.add('active'); document.getElementById('synthControls').style.display='none'; };
  document.getElementById('m-synth').onclick = ()=>{ mode='synth'; modeSynth(); document.querySelectorAll('#controls button.active').forEach(b=>b.classList.remove('active')); this.classList.add('active'); document.getElementById('synthControls').style.display='flex'; };
  document.getElementById('m-file').onclick = ()=>{ document.getElementById('fileInput').click(); };
  document.getElementById('fileInput').onchange = e=>{ if(e.target.files[0]) modeFile(e.target.files[0]); };

  // synth live update
  document.getElementById('synthFreq').oninput = ()=>{ if(synthOsc && synthOsc.frequency) synthOsc.frequency.value = this.value; };
  document.getElementById('synthType').onchange = ()=>{ if(mode==='synth') modeSynth(); };
  document.getElementById('synthPan').oninput = ()=>{ if(sourceNode && sourceNode.pan) sourceNode.pan.value = this.value; };

  // sliders
  document.getElementById('basePB').oninput = ()=>{ Config.BASE_PATH_B_P = parseFloat(this.value); };
  document.getElementById('str').oninput = ()=>{ inputLayer.strength = parseFloat(this.value); };
  document.getElementById('dec').oninput = ()=>{ inputLayer.decay = parseFloat(this.value); };

  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    rotX = (e.clientY-r.top)/r.height*Math.PI - Math.PI/2;
    rotY = (e.clientX-r.left)/r.width*Math.PI*2;
  });
  document.addEventListener('keydown', e=>{
    if(e.key.toLowerCase()==='s') document.getElementById('save').click();
    if(e.key.toLowerCase()==='p') document.getElementById('pause').click();
  });

  loop();
}

window.onload = init;
</script>
</body>
</html>
