<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>PhaseCube GalaxyBrain 3D — Single HTML Minimal (Fixed)</title>
    <style>
        body { margin:0; background:#000; overflow:hidden; font-family:monospace; color:#fff; }
        canvas { display:block; }
        #info { position:absolute; top:10px; left:10px; z-index:10; }
        #controls { position:absolute; bottom:10px; left:10px; z-index:10; }
        button { background:#333; color:#fff; border:1px solid #666; padding:5px 10px; margin:2px; cursor:pointer; }
        button:hover { background:#555; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">PhaseCube Minimal — Press S to save PNG snapshot. Use mouse to rotate view.</div>
    <div id="controls">
        <button onclick="saveSnapshot()">Save PNG</button>
        <button onclick="togglePause()">Pause/Resume</button>
    </div>

<script>
/* ---------------- Config ---------------- */
const WIDTH = 800;
const HEIGHT = 800;
const GRID = 16;
const SCALE = 25;
const FPS = 60;
const POINT_SIZE = 3;          // base radius

// Dynamics tuning
const FLIP_PROB = 0.02;
const PARITY_FLIP_PROB = 0.01;
const PATH_B_PROB = 0.65;
const BLEND_ALPHA = 0.18;

/* -------------- Globals --------------- */
let canvas, ctx;
let time = 0.0;
let paused = false;
let rotX = 0, rotY = 0;

// positions now global so draw/project can access
let positions = null;
let grid = null;

/* ------------- PhaseGrid -------------- */
class PhaseGrid {
    constructor(size, flipProb = FLIP_PROB, parityProb = PARITY_FLIP_PROB) {
        this.size = size;
        this.len = size * size * size;
        // initialize typed arrays reliably
        this.plasma = new Float32Array(this.len);
        this.liquid = new Float32Array(this.len);
        this.solid   = new Float32Array(this.len);
        this.parity  = new Int8Array(this.len);
        for (let i = 0; i < this.len; ++i) {
            this.plasma[i] = Math.random() * 0.5;
            this.liquid[i] = Math.random() * 0.5;
            this.solid[i]   = Math.random() * 0.5;
            this.parity[i]  = 0;
        }
        this.flipProb = flipProb;
        this.parityProb = parityProb;
    }

    idx(x,y,z) { return x + y * this.size + z * this.size * this.size; }

    perturbLocal() {
        for (let i = 0; i < this.len; ++i) {
            if (Math.random() < this.flipProb) this.plasma[i] = 1.0 - this.plasma[i];
            if (Math.random() < this.parityProb)  this.parity[i]  = 1 - this.parity[i];
        }
    }

    neighborsAvg(i) {
        const s = this.size;
        const x = i % s;
        const y = Math.floor(i / s) % s;
        const z = Math.floor(i / (s * s));
        let sum = 0.0;
        sum += this.plasma[this.idx((x + 1) % s, y, z)];
        sum += this.plasma[this.idx((x - 1 + s) % s, y, z)];
        sum += this.plasma[this.idx(x, (y + 1) % s, z)];
        sum += this.plasma[this.idx(x, (y - 1 + s) % s, z)];
        sum += this.plasma[this.idx(x, y, (z + 1) % s)];
        sum += this.plasma[this.idx(x, y, (z - 1 + s) % s)];
        return sum / 6.0;
    }

    breatheStep(pathBProb = PATH_B_PROB, blendAlpha = BLEND_ALPHA) {
        // make local copies for stable reads
        const pCopy = new Float32Array(this.plasma);
        const lCopy = new Float32Array(this.liquid);
        const sCopy = new Float32Array(this.solid);
        for (let i = 0; i < this.len; ++i) {
            const p = pCopy[i], l = lCopy[i], s = sCopy[i];
            const neighbors = this.neighborsAvg(i);
            const pathA = (p + l + s) / 3.0;
            const pathB = Math.abs(p - neighbors) + (this.parity[i] * 0.13);
            const choice = (Math.random() < pathBProb) ? pathB : pathA;
            this.liquid[i] = choice;
            this.solid[i] = (s * (1.0 - blendAlpha) + choice * blendAlpha) % 1.0;
        }
    }
}

/* ---------- 3D projection helper --------
   We do a simple rotate + perspective + viewport transform.
   Returns an array of objects: {x,y,z,i}
-----------------------------------------*/
function projectPoints(positions, rotX, rotY, viewport) {
    const out = [];
    const s = GRID;
    const half = (s - 1) / 2.0;
    const len = positions.length / 3;
    // precompute sin/cos
    const cX = Math.cos(rotX), sX = Math.sin(rotX);
    const cY = Math.cos(rotY), sY = Math.sin(rotY);
    const fov = 45 * Math.PI / 180;
    const aspect = viewport[2] / viewport[3];
    const near = 1.0, far = 5000.0;
    const f = 1.0 / Math.tan(fov / 2);

    for (let i = 0, pi = 0; i < len; ++i, pi += 3) {
        let x = positions[pi], y = positions[pi + 1], z = positions[pi + 2];
        // apply rotation Y then X (same order as original)
        let rx = cY * x + sY * z;
        let rz = -sY * x + cY * z;
        let ry = cX * y - sX * rz;
        let rz2 = sX * y + cX * rz;
        // camera translate: put camera at (0, -400, 400) looking at origin
        const camX = 0, camY = -400, camZ = 400;
        let cx = rx - camX;
        let cy = ry - camY;
        let cz = rz2 - camZ;
        // perspective divide
        // avoid divide by zero / behind-camera points
        if (cz > -near) {
            // still include them but they may be clipped later
        }
        const ndcX = (f / aspect) * (cx / cz);
        const ndcY = f * (cy / cz);
        // map to viewport
        const scrX = (ndcX * 0.5 + 0.5) * viewport[2] + viewport[0];
        const scrY = (ndcY * 0.5 + 0.5) * viewport[3] + viewport[1];
        // use cz as depth (larger cz = farther)
        out.push({ x: scrX, y: scrY, z: cz, i: i });
    }
    // sort back-to-front (farther first)
    out.sort((a, b) => b.z - a.z);
    return out;
}

/* ---------------- Init ----------------- */
function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // build positions global
    const total = GRID * GRID * GRID;
    positions = new Float32Array(total * 3);
    let ptr = 0;
    const half = (GRID - 1) / 2.0;
    for (let x = 0; x < GRID; ++x) {
        for (let y = 0; y < GRID; ++y) {
            for (let z = 0; z < GRID; ++z) {
                positions[ptr++] = (x - half) * SCALE;
                positions[ptr++] = (y - half) * SCALE;
                positions[ptr++] = (z - half) * SCALE;
            }
        }
    }

    grid = new PhaseGrid(GRID);

    // Mouse control
    canvas.addEventListener('mousemove', (e) => {
        rotX = (e.clientY / HEIGHT - 0.5) * Math.PI;       // -pi/2 .. pi/2
        rotY = (e.clientX / WIDTH  - 0.5) * Math.PI * 2;   // -pi .. pi
    });

    document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 's') saveSnapshot();
    });

    requestAnimationFrame(loop);
}

/* ------------- Drawing -------------- */
function updateColors(projected) {
    const p = grid.plasma;
    const parity = grid.parity;
    for (const pt of projected) {
        const i = pt.i;
        const plasmaVal = p[i];
        const par = parity[i];
        const hue = (time * 0.1 + par + plasmaVal) % 1.0;
        const angle = hue * 2 * Math.PI;
        const r = Math.abs(Math.sin(angle));
        const g = Math.abs(Math.sin(angle + 2.0));
        const b = Math.abs(Math.sin(angle + 4.0));
        const a = 0.35 + 0.65 * plasmaVal;
        pt.r = r; pt.g = g; pt.b = b; pt.a = a; pt.plasma = plasmaVal;
    }
}

function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    const viewport = [0, 0, WIDTH, HEIGHT];
    const projected = projectPoints(positions, rotX, rotY, viewport);
    updateColors(projected);

    // painter's algorithm: draw farther points first (projected already sorted)
    for (const pt of projected) {
        // simple clipping: depth range and plasma threshold
        if (!isFinite(pt.z)) continue;
        if (pt.z > 3000 || pt.z < -4000) continue;
        if (pt.plasma < 0.02) continue;
        const radius = POINT_SIZE + 6 * pt.plasma;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
        const rr = Math.floor(pt.r * 255);
        const gg = Math.floor(pt.g * 255);
        const bb = Math.floor(pt.b * 255);
        ctx.fillStyle = `rgba(${rr}, ${gg}, ${bb}, ${pt.a})`;
        ctx.fill();
    }
}

/* --------------- Loop --------------- */
function loop() {
    if (!paused) {
        time += 1 / FPS;
        grid.perturbLocal();
        grid.breatheStep();
    }
    draw();
    requestAnimationFrame(loop);
}

/* -------------- Utilities -------------- */
function saveSnapshot() {
    const link = document.createElement('a');
    link.download = `phasecube_minimal_${Date.now()}.png`;
    link.href = canvas.toDataURL();
    link.click();
}

function togglePause() {
    paused = !paused;
    document.querySelector('#controls button:nth-child(2)').textContent = paused ? 'Resume' : 'Pause/Resume';
}

/* ----------------- Start ---------------- */
window.onload = init;

</script>
</body>
</html>
